
data CreatePostDTO {
    int userId
    char content[]
}

component provides ws.Web requires ws.forms.Parser:multipart formParser, repositories.posts.PostsRepository repo,
    data.IntUtil iu, io.Output out, composition.RecursiveLoader loader, composition.Adapt adapter,
    io.Input in, time.Timer timer, data.StringUtil su, data.json.JSONEncoder je, utils.PodCreatorUtil pods {
    PostsRepository repo
    LoadedComponents repoComponents[] = new LoadedComponents[](
        loader.load("repositories/posts/PostsRepository.o"),
        loader.load("repositories/posts/PostsRepository.proxy.replicate.strong.o"),
        loader.load("repositories/posts/PostsRepository.proxy.replicate.weak.o")
    )
    String names[] = new String[](
        new String("PostsRepository"),
        new String("PostsRepository with strong replication"), 
        new String("PostsRepository with weak replication")
    )
    String remoteNames[] = new String[](
        new String("post-repository"),
        new String("post-repository-replicate-strong"),
        new String("post-repository-replicate-weak")
    )
    int lastComponentIndex = 0
    Mutex lock = new Mutex()
    int id = 1

    void Web:setup() {
        repo = new PostsRepository() from repoComponents[lastComponentIndex].mainComponent
        asynch::changeProxy()
        out.println("Server started on por 8080")
    }

    //Experiment: every minute change the repository implementation
    void changeProxy() {
        timer.sleep(15000)// initial wait of litte more than 25s
        for(int instruction = 1; instruction < repoComponents.arrayLength; instruction++) {
            changeRepo(instruction)
            timer.sleep(15000) // 5s start up + 10s stable
        }
    }

    // local: 15s + 10s init prox | strong: 15s + 10s init prox
    void changeRepo(int option) {
        out.println("Changing repository to $(names[option].string)")
        
        // if(repoComponents[lastComponentIndex].mainComponent hastype ProxyType) {
        //     out.println("Deleting old remotes...")
		//     podCreator.deleteAllPods(repoComponents[lastComponentIndex].mainComponent.remotes)
        //     // wait 30s to let old remotes shut down
        //     timer.sleep(30000) 
        // }


        if(option != 0) {
            out.println("Creating new remotes...")
            pods.createPods(3, remoteNames[option].string, "dana-remote")
            timer.sleep(10000) // wait 10s to let new remotes start up
        } 
        // out.println("New remotes created. Adding remotes to new repository...")
        // PostsRepository nextRepo = new PostsRepository() from repoComponents[option].mainComponent
        // TypeField remotesType = PostsRepository.[remotes]
        // nextRepo:.remotesType = remotes

        // processo do proxy - cada proxy deve ter um nome unico dos componentes remotos,
        // ja que o kubernets nao consegue deletar e criar pods rapido o suficiente
        // o processo de adaptacao envolve:
        // Criar pods remotos -> injetar enderecos no proxy -> adaptar o componente para o proxy

        adapter.adaptObject(repoComponents[lastComponentIndex].mainComponent, repo, repoComponents[option].mainComponent, "repositories.posts.PostsRepository")
        lastComponentIndex = option
    }
	
    bool Web:get(char path[], DocStream s){
        if (path == "/") {
            s.write("Hello!")
            s.sendResponse()
            return true
        } else if (path == "/all") {
            Post allPosts[]
            allPosts = repo.getPosts()
            s.write(je.jsonFromArray(allPosts))
            s.sendResponse()
            return true
        } else if (su.startsWith(path, "/feed/")) {
            String pathInfo[] = su.explode(path, "/") // expected: ["feed", "<userId:number>"]
            int userId = iu.intFromString(pathInfo[1].string)
            Post userPosts[]
            userPosts = repo.getUserFeed(userId)
            s.write(je.jsonFromArray(userPosts))
            s.sendResponse()
            return true
        }

        return false
    }

    bool Web:post(char path[], char contentType[], byte payload[], DocStream s) {
		if (path == "/post") {
            char body[] = new char[](payload)
            
            CreatePostDTO createPostDTO = je.jsonToData(body, typeof(CreatePostDTO))

            Post newPost = new Post(id, createPostDTO.userId, 0, createPostDTO.content)
            repo.addPost(newPost)
            id++

            s.setStatusCode(201, "Created", true)
            s.sendResponse()
            return true
        } else if (su.startsWith(path, "/like/")) {
            String pathInfo[] = su.explode(path, "/") // expected: ["like", "<postId:number>"]
            int postId = iu.intFromString(pathInfo[1].string)

            repo.likePost(postId)

            s.setStatusCode(200, "Post on id $(pathInfo[1].string) liked", true)
            s.sendResponse()
            return true
        }

        return false
    }
	
}